#!/usr/bin/env python3
# Clipfy bot ‚Äî FINAL FULL VERSION with Dynamic Suggested Videos

import os
import time
import asyncio
from uuid import uuid4
from pathlib import Path
from dotenv import load_dotenv
import subprocess
import shutil
import requests
from PIL import Image
import json # Added for JSON serialization

import boto3
from boto3.s3.transfer import TransferConfig
from github import Github

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    filters,
    ContextTypes
)

# ---------------- LOAD ENV ----------------
load_dotenv()

# ---------------- CONFIG ----------------
BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_USER_ID = int(os.getenv("ADMIN_USER_ID", "0"))

R2_ACCOUNT_ID = os.getenv("R2_ACCOUNT_ID")
R2_ACCESS_KEY = os.getenv("R2_ACCESS_KEY")
R2_SECRET_KEY = os.getenv("R2_SECRET_KEY")
R2_BUCKET = os.getenv("R2_BUCKET", "videos")
R2_PUBLIC_URL = os.getenv("R2_PUBLIC_URL")
R2_ENDPOINT = os.getenv("R2_ENDPOINT")

DEFAULT_PLAY_ICON = "https://pub-51338658718349efb6e5193255e4131b.r2.dev/kindpng_2115738.png"
PLAY_ICON_URL = os.getenv("PLAY_ICON_URL") or DEFAULT_PLAY_ICON

GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GITHUB_REPO = os.getenv("GITHUB_REPO")
SITE_DOMAIN = os.getenv("SITE_DOMAIN")

TEMP_DIR = Path("temp")
TEMP_DIR.mkdir(exist_ok=True)

# ---------------- R2 CLIENT ----------------
if not R2_ENDPOINT:
    R2_ENDPOINT = f"https://{R2_ACCOUNT_ID}.r2.cloudflarestorage.com"

s3 = boto3.client(
    "s3",
    endpoint_url=R2_ENDPOINT,
    aws_access_key_id=R2_ACCESS_KEY,
    aws_secret_access_key=R2_SECRET_KEY
)

transfer_config = TransferConfig(
    multipart_threshold=20 * 1024 * 1024,
    multipart_chunksize=10 * 1024 * 1024
)

def r2_public_url(key: str) -> str:
    """Generates the full public URL for an R2 key."""
    return f"{R2_PUBLIC_URL.rstrip('/')}/{key.lstrip('/')}"

# ---------------- METADATA INDEX MANAGEMENT (Dynamic Fix) ----------------

INDEX_FILE_KEY = "metadata/index.json"

def get_video_index():
    """Fetches the LIVE video index (list of all videos) from R2 storage."""
    try:
        response = s3.get_object(Bucket=R2_BUCKET, Key=INDEX_FILE_KEY)
        content = response['Body'].read()
        # Decode JSON content from the body
        return json.loads(content)
    except s3.exceptions.NoSuchKey:
        # If the index file doesn't exist, start with an empty list
        print("Index file not found on R2. Starting fresh.")
        return []
    except Exception as e:
        print(f"Error fetching video index: {e}")
        return []

def update_video_index(new_entry: dict):
    """Adds the new video entry to the index and updates index.json on R2."""
    video_list = get_video_index()
    # Check if entry already exists (using video_id as unique key)
    if not any(item['video_id'] == new_entry['video_id'] for item in video_list):
        video_list.append(new_entry)
    
    # Upload the updated JSON file back to R2
    s3.put_object(
        Bucket=R2_BUCKET,
        Key=INDEX_FILE_KEY,
        Body=json.dumps(video_list, indent=2),
        ContentType='application/json'
    )
    print(f"‚úÖ Metadata index updated with new video: {new_entry['video_id']}")


# ---------------- BOT DATA LOGIC ----------------

def get_all_video_data():
    """Returns the live list of all videos from R2 to be injected into the template."""
    return get_video_index()

# ---------------- GITHUB CLIENT ----------------
gh = Github(GITHUB_TOKEN)
repo = gh.get_repo(GITHUB_REPO)

def generate_page(video_url: str, thumb_url: str, video_id: str, title: str, description: str, time_ago: str) -> str:
    """
    Generate HTML player page with ALL new placeholders and push to repo.
    Uses the correct .html URL format.
    """
    page_name = f"{video_id}.html"

    try:
        # 1. Fetch template from GitHub
        template = repo.get_contents("template.html").decoded_content.decode()
    except Exception as e:
        print(f"Error fetching template: {e}")
        raise Exception("Could not fetch template from GitHub.")

    # 2. Get All Videos Data and Prepare JSON (for suggested list)
    all_videos_data = get_all_video_data()
    all_videos_json_str = json.dumps(all_videos_data)
    
    # 3. Replace ALL Placeholders
    html = template.replace("{{VIDEO_URL}}", video_url)
    html = html.replace("{{THUMB_URL}}", thumb_url)
    
    # Correct URL format for the player meta tag
    html = html.replace("{{PLAYER_PAGE_URL}}", f"{SITE_DOMAIN.rstrip('/')}/v/{page_name}") 
    
    # Fill New Placeholders
    html = html.replace("{{VIDEO_ID}}", video_id) 
    html = html.replace("{{TITLE}}", title)
    html = html.replace("{{DESCRIPTION}}", description)
    html = html.replace("{{TIME_AGO}}", time_ago) 
    
    # Inject the Master JSON Data (The Dynamic Fix)
    html = html.replace("{{ALL_VIDEOS_JSON}}", all_videos_json_str) 

    # 4. Create File in GitHub
    repo.create_file(f"v/{page_name}", f"Add video page {page_name}", html)
    return f"{SITE_DOMAIN.rstrip('/')}/v/{page_name}"

# ---------------- HELPER FUNCTIONS ----------------

async def safe_edit(msg, text):
    try:
        await msg.edit_text(text)
    except:
        pass

def make_thumbnail(video_path: Path, thumb_path: Path) -> bool:
    """Extract single frame (1s or 2s) using ffmpeg."""
    # Try extracting at 1 second
    cmd = ["ffmpeg", "-y", "-i", str(video_path), "-ss", "00:00:01", "-vframes", "1", str(thumb_path)]
    try:
        subprocess.check_output(cmd, stderr=subprocess.STDOUT)
        return True
    except subprocess.CalledProcessError:
        # Try fallback at 2s
        try:
            cmd[5] = "00:00:02"
            subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            return True
        except:
            return False

def download_file(url: str, dest: Path) -> bool:
    try:
        r = requests.get(url, stream=True, timeout=20)
        r.raise_for_status()
        with open(dest, "wb") as f:
            for chunk in r.iter_content(8192):
                f.write(chunk)
        return True
    except Exception as e:
        print(f"Error downloading file: {e}")
        return False

def add_play_icon(thumb_path: Path, play_icon_url: str, out_path: Path) -> bool:
    """Overlay the play icon (PNG) at the center of the thumbnail."""
    print(f"Attempting to overlay play icon from: {play_icon_url}")

    tmp_icon = TEMP_DIR / f"play_{uuid4().hex}.png"

    if not download_file(play_icon_url, tmp_icon):
        print("‚ùå Play icon download failed.")
        return False

    try:
        thumb = Image.open(thumb_path).convert("RGBA")
        icon = Image.open(tmp_icon).convert("RGBA")

        # --- SIZE FIX: Play button size ko 15% of thumbnail width, max 150px tak rakho ---
        target_w = min(int(thumb.width * 0.15), 150) # <- Size adjusted here

        # Keep aspect ratio
        icon_ratio = icon.width / icon.height
        target_h = int(target_w / icon_ratio)

        # Handle Pillow Version Differences (LANCZOS vs ANTIALIAS)
        if hasattr(Image, 'Resampling'):
            icon = icon.resize((target_w, target_h), Image.Resampling.LANCZOS)
        else:
            icon = icon.resize((target_w, target_h), Image.ANTIALIAS)

        # Calculate center position
        x = (thumb.width - target_w) // 2
        y = (thumb.height - target_h) // 2

        # Paste icon (using icon as mask for transparency)
        thumb.paste(icon, (x, y), icon)

        # Save as JPEG (RGB)
        rgb = thumb.convert("RGB")
        rgb.save(out_path, format="JPEG", quality=85)

        print("‚úÖ Play button overlay successful!")
        tmp_icon.unlink(missing_ok=True)
        return True

    except Exception as e:
        print(f"‚ùå Error adding play icon: {e}")
        try:
            tmp_icon.unlink(missing_ok=True)
        except:
            pass
        return False

# ---------------- MAIN BOT HANDLER ----------------
async def handle_media(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message

    if ADMIN_USER_ID and msg.from_user.id != ADMIN_USER_ID:
        return await msg.reply_text("Not allowed.")

    progress = await msg.reply_text("‚è≥ Starting...")

    local_video = None
    local_thumb = None
    final_thumb = None

    try:
        video = msg.video or (msg.document if msg.document and msg.document.mime_type.startswith("video/") else None)

        if not video:
            return await safe_edit(progress, "Send a video file.")

        # 1. Download Video
        tg_file = await video.get_file()
        new_uuid = uuid4().hex # Generate UUID once for file name and video_id
        fname = video.file_name or f"{new_uuid}.mp4"
        local_video = TEMP_DIR / fname

        await safe_edit(progress, "üì• Downloading video...")
        await tg_file.download_to_drive(str(local_video))

        # 2. Extract Raw Thumbnail
        await safe_edit(progress, "üñº Extracting thumbnail...")
        local_thumb = TEMP_DIR / (f"{new_uuid}_raw.jpg")
        if not make_thumbnail(local_video, local_thumb):
            return await safe_edit(progress, "‚ùå Could not extract thumbnail from video.")

        # 3. Overlay Play Button
        await safe_edit(progress, "üé® Adding Play Button...")
        final_thumb = TEMP_DIR / (f"{new_uuid}_final.jpg")

        overlay_success = add_play_icon(local_thumb, PLAY_ICON_URL, final_thumb)

        if not overlay_success:
            print("‚ö†Ô∏è Overlay failed, using raw thumbnail.")
            final_thumb = local_thumb

        # 4. Upload Video
        key_video = f"videos/{new_uuid}.mp4"
        fsize = local_video.stat().st_size

        uploaded = {"v": 0}
        loop = asyncio.get_event_loop()

        def cb(bytes_amt):
            uploaded["v"] += bytes_amt
            pct = int(uploaded["v"] / fsize * 100)
            if pct % 10 == 0: # Update less frequently
                asyncio.run_coroutine_threadsafe(
                    safe_edit(progress, f"‚òÅÔ∏è Uploading Video {pct}%"), loop
                )

        def upload_video_to_s3():
            s3.upload_file(
                str(local_video),
                R2_BUCKET,
                key_video,
                ExtraArgs={"ContentType": "video/mp4"},
                Config=transfer_config,
                Callback=cb
            )

        await loop.run_in_executor(None, upload_video_to_s3)
        video_url = r2_public_url(key_video)

        # 5. Upload Final Thumbnail
        key_thumb = f"thumbs/{new_uuid}.jpg"
        await safe_edit(progress, "üì§ Uploading thumbnail...")

        s3.upload_file(
            str(final_thumb),
            R2_BUCKET,
            key_thumb,
            ExtraArgs={"ContentType": "image/jpeg"}
        )
        thumb_url = r2_public_url(key_thumb)
        
        # 6. Generate Metadata and Page
        await safe_edit(progress, "üìù Creating Link...")
        
        # --- Metadata Generation (Clickbait Titles) ---
        new_video_id = new_uuid # The clean ID used for the .html file
        
        title_options = [
            f"üò± ‡§Ø‡•á ‡§∞‡§æ‡§ú‡§º ‡§Ü‡§™‡§ï‡•á ‡§π‡•ã‡§∂ ‡§â‡§°‡§º‡§æ ‡§¶‡•á‡§ó‡§æ! (PART {new_video_id[:4]})",
            "‡§∏‡§ø‡§∞‡•ç‡§´ 2 ‡§Æ‡§ø‡§®‡§ü ‡§Æ‡•á‡§Ç ‡§ï‡§∞‡•ã‡§°‡§º‡§™‡§§‡§ø ‡§¨‡§®‡§®‡•á ‡§ï‡§æ ‡§§‡§∞‡•Ä‡§ï‡§æ! (REAL TRUTH)",
            "MUST WATCH: 99% ‡§≤‡•ã‡§ó ‡§á‡§∏‡•á ‡§®‡§π‡•Ä‡§Ç ‡§¶‡•á‡§ñ ‡§™‡§æ‡§è!",
            "OMG! ‡§ï‡•à‡§Æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ï‡•à‡§¶ ‡§π‡•Å‡§Ü ‡§Ö‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏‡§®‡•Ä‡§Ø ‡§®‡§ú‡§º‡§æ‡§∞‡§æ...",
        ]
        description_options = [
            "‡§¶‡•á‡§ñ‡§®‡•á ‡§∏‡•á ‡§™‡§π‡§≤‡•á ‡§Ö‡§™‡§®‡•Ä ‡§ï‡•Å‡§∞‡•ç‡§∏‡•Ä ‡§ï‡•Ä ‡§™‡•á‡§ü‡•Ä ‡§¨‡§æ‡§Ç‡§ß ‡§≤‡•á‡§Ç! ‡§Ø‡§π ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§π‡•ã‡§®‡•á ‡§µ‡§æ‡§≤‡§æ ‡§π‡•à‡•§",
            "‡§Ü‡§ñ‡§ø‡§∞ ‡§µ‡•ã ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à ‡§ú‡•ã ‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ ‡§∏‡•á ‡§õ‡•Å‡§™‡§æ‡§Ø‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à? ‡§™‡•Ç‡§∞‡§æ ‡§∏‡§ö ‡§¶‡•á‡§ñ‡•á‡§Ç!",
            "‡§á‡§∏ ‡§è‡§ï ‡§ö‡•Ä‡§ú‡§º ‡§®‡•á ‡§Æ‡•á‡§∞‡•Ä ‡§ú‡§º‡§Ç‡§ú‡•Ä‡§∞‡•á‡§Ç ‡§¨‡§¶‡§≤ ‡§¶‡•Ä! ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§è‡§ï ‡§Ü‡§¶‡§§... ‡§î‡§∞ ‡§Æ‡•à‡§Ç ‡§ñ‡•Å‡§¶ ‡§¨‡§¶‡§≤ ‡§ó‡§Ø‡§æ, ‡§ú‡§æ‡§®‡•ã ‡§Ø‡•á ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à‡•§",
        ]
        
        import random
        generated_title = random.choice(title_options)
        generated_description = random.choice(description_options)
        upload_time_ago = "just now"
        # -----------------------------------------------

        page = await loop.run_in_executor(
            None, 
            lambda: generate_page(
                video_url=video_url, 
                thumb_url=thumb_url, 
                video_id=new_video_id, 
                title=generated_title, 
                description=generated_description, 
                time_ago=upload_time_ago
            )
        )
        
        # 7. Update the Persistent Metadata Index on R2
        new_video_entry = {
            "title": generated_title,
            "creator": "Content Creator Name", 
            "video_url": video_url,
            "thumb_url": thumb_url,
            "video_id": new_video_id,
            "time_ago": upload_time_ago,
            "description": generated_description,
        }
        
        await loop.run_in_executor(None, lambda: update_video_index(new_video_entry))

        await safe_edit(progress, f"üéâ **Done!**\n\nLink: {page}")

    except Exception as e:
        import traceback
        traceback.print_exc()
        await safe_edit(progress, f"‚ùå Error:\n{e}")

    finally:
        # Cleanup
        try:
            if local_video and local_video.exists():
                local_video.unlink()
            if local_thumb and local_thumb.exists() and local_thumb != final_thumb:
                local_thumb.unlink()
            if final_thumb and final_thumb.exists() and final_thumb != local_thumb:
                final_thumb.unlink()
        except Exception as cleanup_error:
            print(f"Cleanup error: {cleanup_error}")

# ---------------- START ----------------
if __name__ == "__main__":
    print("üöÄ Clipfy Bot Started...")
    print(f"üîπ Admin ID: {ADMIN_USER_ID}")
    print(f"üîπ Play Icon URL: {PLAY_ICON_URL}")

    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(MessageHandler(filters.ALL, handle_media))
    app.run_polling()
