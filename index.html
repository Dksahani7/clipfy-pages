<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Galaxy Wars: Smooth Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 15px; box-sizing: border-box;
        }

        .top-bar { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        #score-box { color: #0ff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #0ff; }
        
        #hp-container { width: 150px; height: 10px; border: 2px solid #0ff; border-radius: 5px; background: rgba(0,0,0,0.5); overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: #00ff00; box-shadow: 0 0 10px #00ff00; transition: width 0.2s; }

        #level-text {
            position: absolute; top: 20%; width: 100%; text-align: center; left: 0;
            color: #ff0055; font-size: 30px; font-weight: 900; letter-spacing: 2px;
            text-shadow: 0 0 20px #ff0055; opacity: 0; transition: opacity 0.5s;
        }

        #boss-hp-container {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 15px; border: 2px solid #ff0000; display: none;
        }
        #boss-hp-bar { width: 100%; height: 100%; background: #ff0000; }

        /* SCREENS */
        #start-screen, #game-over-screen, #victory-screen {
            position: absolute; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        
        h1 { color: #00ffff; font-size: 36px; text-transform: uppercase; margin-bottom: 10px; text-align: center; }
        p { color: #ccc; margin-bottom: 30px; font-size: 14px; text-align: center; max-width: 90%; }
        
        button {
            background: linear-gradient(45deg, #00ffff, #0088ff); border: none; padding: 15px 40px;
            font-size: 18px; font-weight: bold; color: #000; cursor: pointer; border-radius: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        button:active { transform: scale(0.95); }

        #game-over-screen, #victory-screen { display: none; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <div id="score-box">SCORE: 0</div>
            <div id="hp-container"><div id="hp-bar"></div></div>
        </div>
        <div id="level-text">LEVEL 1</div>
        <div id="boss-hp-container"><div id="boss-hp-bar"></div></div>
    </div>

    <div id="start-screen">
        <h1>Neon Galaxy</h1>
        <p>CONTROL FIX: Drag anywhere on screen to move ship.<br>Auto-Fire Active.</p>
        <button onclick="startGame()">START MISSION</button>
    </div>

    <div id="game-over-screen">
        <h1 style="color: #ff0055;">DESTROYED</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <div id="victory-screen">
        <h1 style="color: #00ff00;">VICTORY!</h1>
        <p>Galaxy Saved.</p>
        <button onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.025);
        
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 20, 10);
        camera.lookAt(0, 0, -10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(0, 50, 20);
        scene.add(dirLight);

        // --- ASSETS ---
        // Stars
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(3000); // 1000 stars * 3 coords
        for(let i=0; i<3000; i++) starPos[i] = (Math.random() - 0.5) * 120;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.3}));
        scene.add(stars);

        // Player
        const player = new THREE.Group();
        const pBody = new THREE.Mesh(new THREE.ConeGeometry(1.2, 4.5, 4), new THREE.MeshStandardMaterial({color: 0x00ffff, roughness: 0.2}));
        pBody.rotation.x = -Math.PI / 2; pBody.rotation.y = Math.PI / 4;
        const pWing = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.2, 1.5), new THREE.MeshStandardMaterial({color: 0x0088ff}));
        pWing.position.z = 1;
        player.add(pBody, pWing);
        scene.add(player);

        // --- GAME VARS ---
        let gameState = 'MENU';
        let score = 0;
        let level = 1;
        let playerHP = 100;
        let bossHP = 100;
        let bullets = [], enemies = [], particles = [];
        let boss = null;
        let lastShot = 0;
        let spawnTimer = 0;
        let bossDir = 1;

        // --- CONTROL VARIABLES (NEW FIX) ---
        let touchStartX = 0, touchStartY = 0;
        let shipStartX = 0, shipStartZ = 0;
        
        // --- CONTROL LOGIC (The Fix) ---
        // Helper to clamp numbers
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

        // TOUCH HANDLERS
        document.addEventListener('touchstart', (e) => {
            if(gameState === 'MENU') return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            shipStartX = player.position.x;
            shipStartZ = player.position.z;
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            if(gameState !== 'PLAYING' && gameState !== 'BOSSFIGHT') return;
            e.preventDefault(); // Stop scrolling

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // Calculate movement difference
            // Sensitivity factor: 0.04 seems good for mobile
            const deltaX = (touchX - touchStartX) * 0.05; 
            const deltaY = (touchY - touchStartY) * 0.05;

            // Apply new position with limits
            player.position.x = clamp(shipStartX + deltaX, -16, 16);
            player.position.z = clamp(shipStartZ + deltaY, -8, 8); // Inverted Y logic handled by delta sign

            // Banking Effect
            player.rotation.z = deltaX * -0.5;

        }, {passive: false});

        document.addEventListener('touchend', () => {
            player.rotation.z = 0; // Reset tilt
            shipStartX = player.position.x; // Save pos
            shipStartZ = player.position.z;
        });

        // --- CORE GAME FUNCTIONS ---

        function updateLevel() {
            const txt = document.getElementById('level-text');
            if (level === 1 && score >= 200) {
                level = 2; txt.innerText = "LEVEL 2: ASTEROIDS";
                txt.style.opacity = 1; setTimeout(()=>txt.style.opacity=0, 3000);
            } else if (level === 2 && score >= 500) {
                level = 3; startBoss();
            }
        }

        function spawnEnemy() {
            if(gameState === 'BOSSFIGHT') return;
            let type = (level===2 && Math.random()>0.7) ? 'rock' : 'ship';
            
            const x = (Math.random()-0.5) * 32;
            const z = -50;
            
            let mesh;
            if(type === 'ship') {
                mesh = new THREE.Mesh(new THREE.TetrahedronGeometry(1.2), new THREE.MeshStandardMaterial({color:0xff0044}));
                mesh.userData = { hp: 1, type: 'ship' };
            } else {
                mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5), new THREE.MeshStandardMaterial({color:0x888888}));
                mesh.userData = { hp: 3, type: 'rock' };
            }
            mesh.position.set(x, 0, z);
            scene.add(mesh); enemies.push(mesh);
        }

        function createBullet() {
            const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const geo = new THREE.CylinderGeometry(0.1,0.1,1.5);
            
            const b1 = new THREE.Mesh(geo,mat); b1.rotation.x = -Math.PI/2;
            b1.position.set(player.position.x-1.2, player.position.y, player.position.z-1);
            
            const b2 = new THREE.Mesh(geo,mat); b2.rotation.x = -Math.PI/2;
            b2.position.set(player.position.x+1.2, player.position.y, player.position.z-1);
            
            scene.add(b1, b2); bullets.push(b1, b2);
        }

        function startBoss() {
            gameState = 'BOSSFIGHT';
            const txt = document.getElementById('level-text');
            txt.innerText = "⚠️ BOSS FIGHT ⚠️"; txt.style.color = "red"; txt.style.opacity = 1;
            setTimeout(()=>txt.style.opacity=0, 3000);
            
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(10,3,6), new THREE.MeshStandardMaterial({color:0x440044})));
            const eye = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({color:0xff0000}));
            eye.position.z = 2; g.add(eye);
            
            g.position.set(0,0,-30);
            scene.add(g); boss = g;
            document.getElementById('boss-hp-container').style.display = 'block';
        }

        function createBoom(pos) {
            for(let i=0; i<6; i++) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), new THREE.MeshBasicMaterial({color:0xffaa00}));
                m.position.copy(pos);
                m.userData = { v: new THREE.Vector3((Math.random()-0.5),(Math.random()-0.5),(Math.random()-0.5)) };
                scene.add(m); particles.push(m);
            }
        }

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if(gameState === 'MENU' || gameState === 'GAMEOVER' || gameState === 'VICTORY') return;

            // Background Speed
            const p = stars.geometry.attributes.position.array;
            for(let i=2; i<p.length; i+=3) { p[i]+=1.5; if(p[i]>20) p[i]=-100; }
            stars.geometry.attributes.position.needsUpdate = true;

            // Auto Fire
            if(Date.now() - lastShot > 200) { createBullet(); lastShot = Date.now(); }

            // Move Bullets
            for(let i=bullets.length-1; i>=0; i--) {
                bullets[i].position.z -= 1.8;
                if(bullets[i].position.z < -60) { scene.remove(bullets[i]); bullets.splice(i,1); }
            }

            // Spawn Enemies
            if(gameState === 'PLAYING') {
                spawnTimer++;
                if(spawnTimer > (level===1 ? 50 : 35)) { spawnEnemy(); spawnTimer=0; }
            }

            // Enemy Logic
            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                e.position.z += (level===1 ? 0.4 : 0.7);
                e.rotation.x += 0.05;

                // Bullet Hit Check
                for(let j=bullets.length-1; j>=0; j--) {
                    if(bullets[j].position.distanceTo(e.position) < 2.5) {
                        createBoom(e.position);
                        scene.remove(bullets[j]); bullets.splice(j,1);
                        e.userData.hp--;
                        if(e.userData.hp <= 0) {
                            scene.remove(e); enemies.splice(i,1);
                            score+=10; document.getElementById('score-box').innerText = "SCORE: "+score;
                            updateLevel();
                        }
                        break;
                    }
                }

                // Player Hit Check
                if(e && player.position.distanceTo(e.position) < 3) {
                    createBoom(player.position);
                    scene.remove(e); enemies.splice(i,1);
                    playerHP -= 20;
                    document.getElementById('hp-bar').style.width = playerHP + "%";
                    if(playerHP<=0) gameOver();
                }

                if(e && e.position.z > 20) { scene.remove(e); enemies.splice(i,1); }
            }

            // Boss Logic
            if(boss && gameState === 'BOSSFIGHT') {
                boss.position.x += 0.15 * bossDir;
                if(boss.position.x > 12) bossDir = -1;
                if(boss.position.x < -12) bossDir = 1;

                // Boss Hit
                for(let j=bullets.length-1; j>=0; j--) {
                    if(Math.abs(bullets[j].position.z - boss.position.z) < 4 && Math.abs(bullets[j].position.x - boss.position.x) < 6) {
                        scene.remove(bullets[j]); bullets.splice(j,1);
                        bossHP -= 2; createBoom(bullets[j]?bullets[j].position:boss.position);
                        document.getElementById('boss-hp-bar').style.width = bossHP + "%";
                        if(bossHP <= 0) {
                            scene.remove(boss); gameState = 'VICTORY';
                            document.getElementById('victory-screen').style.display = 'flex';
                            document.getElementById('ui-layer').style.display = 'none';
                        }
                    }
                }
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                particles[i].position.add(particles[i].userData.v);
                particles[i].scale.multiplyScalar(0.9);
                if(particles[i].scale.x < 0.05) { scene.remove(particles[i]); particles.splice(i,1); }
            }

            renderer.render(scene, camera);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('ui-layer').style.display = 'none';
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState = 'PLAYING';
            animate();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
