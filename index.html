<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Temple City Run 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #score-board {
            color: #FFD700;
            font-size: 32px;
            font-weight: 900;
            text-shadow: 2px 2px 0px #000;
            font-style: italic;
        }

        #tutorial {
            text-align: center;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 4px black;
            opacity: 0.8;
            margin-bottom: 50px;
        }

        #game-over {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            pointer-events: auto;
            border: 4px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            width: 80%;
            max-width: 400px;
        }
        
        button {
            background: linear-gradient(45deg, #ff9800, #ff5722);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 22px;
            border-radius: 50px;
            margin-top: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">0</div>
        <div id="tutorial">
            ðŸ‘† Jump | ðŸ‘‡ Slide | ðŸ‘ˆ Left | ðŸ‘‰ Right
        </div>
    </div>

    <div id="game-over">
        <h1 style="margin:0; color:#ff4444;">CRASHED!</h1>
        <p style="font-size:1.2em;">Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- TEXTURE GENERATORS (For Realism without external images) ---
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Wall
            ctx.fillStyle = '#444';
            ctx.fillRect(0,0,64,128);
            
            // Windows
            ctx.fillStyle = '#87CEEB'; // Sky blue reflection
            for(let y=10; y<120; y+=20) {
                for(let x=10; x<60; x+=20) {
                    if(Math.random() > 0.3) ctx.fillRect(x, y, 10, 15);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        function createRoadTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Asphalt
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0,0,512,512);
            
            // Noise (Grain)
            for(let i=0; i<5000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#333' : '#222';
                ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- SETUP ---
        const scene = new THREE.Scene();
        // Fog for depth and reality masking
        scene.fog = new THREE.Fog(0xaaccff, 20, 90);
        scene.background = new THREE.Color(0xaaccff);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // --- WORLD ---
        // Road
        const roadGeo = new THREE.PlaneGeometry(30, 1000);
        const roadMat = new THREE.MeshStandardMaterial({ 
            map: createRoadTexture(),
            roughness: 0.8 
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);

        // Grass/Sidewalk
        const grassGeo = new THREE.PlaneGeometry(200, 1000);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.1;
        scene.add(grass);

        // --- PLAYER (Complex Group) ---
        const player = new THREE.Group();
        
        // Materials
        const skinMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const shirtMat = new THREE.MeshStandardMaterial({ color: 0xff4500 }); // Orange Shirt
        const jeansMat = new THREE.MeshStandardMaterial({ color: 0x1e3f5a }); // Dark Jeans

        // Head
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMat);
        head.position.y = 1.6;
        head.castShadow = true;
        player.add(head);

        // Torso
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.3), shirtMat);
        torso.position.y = 1.0;
        torso.castShadow = true;
        player.add(torso);

        // Legs (For animation)
        const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.75, 0.25), jeansMat);
        leftLeg.position.set(-0.18, 0.375, 0);
        leftLeg.castShadow = true;
        player.add(leftLeg);

        const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.75, 0.25), jeansMat);
        rightLeg.position.set(0.18, 0.375, 0);
        rightLeg.castShadow = true;
        player.add(rightLeg);

        scene.add(player);
        player.position.z = 10;
        player.position.y = 0;

        // --- GAME LOGIC VARS ---
        let gameActive = true;
        let lane = 0; // -1, 0, 1
        const laneWidth = 3.5;
        let speed = 0.4;
        let score = 0;
        
        // Physics
        let verticalVelocity = 0;
        let gravity = 0.04;
        let isJumping = false;
        let isSliding = false;
        let slideTimer = 0;

        // Objects
        let buildings = [];
        let obstacles = [];
        let debris = []; // Clouds/Details

        const buildingTex = createBuildingTexture();

        // --- SPAWNERS ---
        function spawnBuilding(zPos) {
            const h = 10 + Math.random() * 20;
            const geo = new THREE.BoxGeometry(6, h, 6);
            const mat = new THREE.MeshStandardMaterial({ map: buildingTex });
            const mesh = new THREE.Mesh(geo, mat);
            
            const side = Math.random() > 0.5 ? 1 : -1;
            mesh.position.set(side * (12 + Math.random()*5), h/2, zPos);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            buildings.push(mesh);
        }

        function spawnObstacle() {
            if(!gameActive) return;

            const type = Math.floor(Math.random() * 3);
            let obs;
            
            // 0: Barrier (Jump over)
            // 1: High Barrier (Slide under)
            // 2: Car/Block (Dodge)

            if(type === 0) { // LOW BARRIER
                obs = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 0.5), new THREE.MeshStandardMaterial({color:0xff0000}));
                obs.position.y = 0.4;
                obs.userData = { type: 'jump' };
            } else if (type === 1) { // HIGH BARRIER
                obs = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 0.5), new THREE.MeshStandardMaterial({color:0xffff00}));
                obs.position.y = 2.0; // High up
                
                // Legs holding it up
                const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,2), new THREE.MeshStandardMaterial({color:0x888888}));
                leg1.position.x = -1.2; leg1.position.y = -1.5;
                obs.add(leg1);
                const leg2 = leg1.clone();
                leg2.position.x = 1.2;
                obs.add(leg2);

                obs.userData = { type: 'slide' };
            } else { // BLOCK
                obs = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 4), new THREE.MeshStandardMaterial({color:0x3333aa}));
                obs.position.y = 1;
                obs.userData = { type: 'dodge' };
            }

            const rLane = Math.floor(Math.random() * 3) - 1;
            obs.position.x = rLane * laneWidth;
            obs.position.z = -100;
            obs.castShadow = true;
            
            scene.add(obs);
            obstacles.push(obs);
        }

        // Init World
        for(let i=0; i<30; i++) spawnBuilding(-i*10);

        setInterval(spawnObstacle, 1500);
        setInterval(() => spawnBuilding(-150), 300);

        // --- CONTROLS (SWIPE) ---
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchend', e => {
            if(!gameActive) return;
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            
            handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
        }, {passive: false});

        // Keyboard for testing on PC
        document.addEventListener('keydown', e => {
            if(!gameActive) return;
            if(e.key === 'ArrowLeft') changeLane(-1);
            if(e.key === 'ArrowRight') changeLane(1);
            if(e.key === 'ArrowUp') doJump();
            if(e.key === 'ArrowDown') doSlide();
        });

        function handleSwipe(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            if(Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if(Math.abs(dx) > 30) {
                    if(dx > 0) changeLane(1);
                    else changeLane(-1);
                }
            } else {
                // Vertical
                if(Math.abs(dy) > 30) {
                    if(dy < 0) doJump(); // Swipe UP
                    else doSlide(); // Swipe DOWN
                }
            }
        }

        function changeLane(dir) {
            if(lane + dir >= -1 && lane + dir <= 1) {
                lane += dir;
            }
        }

        function doJump() {
            if(!isJumping && !isSliding) {
                isJumping = true;
                verticalVelocity = 0.8;
            }
        }

        function doSlide() {
            if(!isSliding && !isJumping) {
                isSliding = true;
                slideTimer = 40; // frames
                // Shrink character visual
                player.scale.y = 0.5;
                player.position.y = 0.5; // adjust to ground
            }
        }

        // --- ANIMATION LOOP ---
        let runTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            if(!gameActive) return;

            // 1. Move Player X (Lane)
            player.position.x += (lane * laneWidth - player.position.x) * 0.15;

            // 2. Jump Physics
            if(isJumping) {
                player.position.y += verticalVelocity;
                verticalVelocity -= gravity;
                if(player.position.y <= 0) {
                    player.position.y = 0;
                    isJumping = false;
                }
            }

            // 3. Slide Logic
            if(isSliding) {
                slideTimer--;
                if(slideTimer <= 0) {
                    isSliding = false;
                    player.scale.y = 1;
                    player.position.y = 0; // Reset
                }
            }

            // 4. Running Animation
            if(!isJumping && !isSliding) {
                runTime += 0.3;
                leftLeg.rotation.x = Math.sin(runTime) * 0.8;
                rightLeg.rotation.x = Math.cos(runTime) * 0.8;
                // Bounce
                player.position.y = Math.abs(Math.sin(runTime*2)) * 0.1;
            } else if (isJumping) {
                leftLeg.rotation.x = 0.5; rightLeg.rotation.x = -0.5; // Frozen jump pose
            }

            // 5. Move World (Z-Axis)
            obstacles.forEach((ob, i) => {
                ob.position.z += speed;

                // Collision Box Logic
                // Simple box distance check
                const dx = Math.abs(ob.position.x - player.position.x);
                const dz = Math.abs(ob.position.z - player.position.z);
                const dy = player.position.y; // Player height

                if(dz < 1.5 && dx < 1.0) {
                    let hit = false;
                    if(ob.userData.type === 'slide') {
                        // Must be sliding to survive
                        if(!isSliding) hit = true; 
                    } else if (ob.userData.type === 'jump') {
                        // Must be jumping (high enough) to survive
                        if(dy < 0.6) hit = true;
                    } else {
                        // Dodge object
                        hit = true;
                    }

                    if(hit) gameOver();
                }

                if(ob.position.z > 10) {
                    scene.remove(ob);
                    obstacles.splice(i, 1);
                    score += 10;
                    document.getElementById('score-board').innerText = score;
                    if(score % 200 === 0) speed += 0.05;
                }
            });

            // Move Buildings
            buildings.forEach((b, i) => {
                b.position.z += speed;
                if(b.position.z > 20) {
                    scene.remove(b);
                    buildings.splice(i, 1);
                }
            });

            // Camera follow (Smooth)
            camera.position.x += (player.position.x * 0.5 - camera.position.x) * 0.1;
            camera.position.y = 5 + player.position.y * 0.5;
            camera.position.z = 18;
            camera.lookAt(0, 2, 0);

            renderer.render(scene, camera);
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = score;
        }

        window.restartGame = function() {
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];
            buildings.forEach(b => scene.remove(b));
            buildings = [];
            // Respawn buildings
            for(let i=0; i<30; i++) spawnBuilding(-i*10);
            
            player.position.set(0,0,10);
            lane = 0;
            score = 0;
            speed = 0.4;
            isJumping = false;
            isSliding = false;
            player.scale.y = 1;
            
            document.getElementById('score-board').innerText = "0";
            document.getElementById('game-over').style.display = 'none';
            gameActive = true;
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
